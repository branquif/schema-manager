<h1 id="general-logic-schema-governance-manager">General logic schema governance manager</h1>
<p><strong>This is early alpha proof of concept project</strong></p>
<h2 id="motivation">Motivation</h2>
<p>There is a lot of different ways to define schemas nowadays, being it APIs, databases, messaging and events, files, etc..</p>
<p>Today, for more complex systems and microservices oriented architectures, it is common to have more than one schema definition type involved (API and Databases being the most common).</p>
<p>This creates the problem of having the same concepts being represented by different schema definitions, making the data governance harder, since the data concepts are spread all over those different schemas. The suggested solution for this problem is to create a “logical schema model” that can work as the root to generate all other needed schemas, and this logical model also be used to validate with domain experts if the concepts being used are correct.</p>
<p>From that logical schema model, we can derive other schema styles and instantiate other schema types.</p>
<h2 id="goal">Goal</h2>
<p>The goal of this project is to facilitate data governance in a heterogeneous environment, where we use several different data schemas, like APIs, Databases and Messaging.</p>
<p>One of the main goals is to represent different schemas in a domain specific language that can be used to generate those specific schemas, following this characteristics: 1. Is a Human Readable Format(HRF): can be read and manipulated in text format 2. Plays well with software version control systems (GIT), being able to use the default tools, like diff, and be versioned along with the software being built 3. Be the root of all specific schemas, able to automate their generation 4. Be able to represent the selected physical schemas in their respective schema style types, adding necessary elements, like: - Headers, Partition Keys and Body for Messages and Events - Indexes, Foreign Keys and table attributes for relational databases - Routes, Request and Response schemas and specific attributes for APIs</p>
<p>Overall, it must work like a logical data model for specific data schemas, but encompassing more schema types than traditional database logical models</p>
<h3 id="future-goals">Future goals</h3>
<p>One of the future goals is to implement reverse engineering of physical models into logical models. This is still under discussion.</p>
<h2 id="schema-style-types">Schema style types</h2>
<p>Schema-manager need to support three schema style types: 1. <strong>Nestable</strong> : schemas that can have nested schemas, like json, xml, yaml formats; 2. <strong>Relational</strong>: schemas that represent relational databases, with tables, attributes and relationships; 3. <strong>Flat</strong>: schemas that have no nested or relationship among entities, like text files and comma separates files (csv)</p>
<p>Each style can have different ways to be represented, but schema-man uses a nested schema definition style to represent all other styles.</p>
<h2 id="physical-schemas">Physical schemas</h2>
<p>The following schemas are being taken in consideration to be represented by the schema-manager:</p>
<p>Schemas: - json schemas - ProtocolBuffers - AVRO - Cassandra - MySQL - Postgres</p>
<p>RPCs: - gRPC - OpenAPI - RAML EventBased - Kafka</p>
<h2 id="design-considerations">Design considerations</h2>
<p>The syntax of schema-manager is clearly inspired in the python programming language.</p>
<p>Here goes the zen of schema-manager adapted from <a href="https://en.wikipedia.org/wiki/Zen_of_Python">the zen of python</a>:</p>
<p>Beautiful is better than ugly.<br />
Explicit is better than implicit.<br />
Simple is better than complex.<br />
Complex is better than complicated.<br />
Sparse is better than dense.<br />
Readability counts.<br />
Special cases aren’t special enough to break the rules.<br />
Although practicality beats purity.<br />
Errors should not pass silently.<br />
In the face of ambiguity, refuse the temptation to guess.<br />
There should be one—and preferably only one—obvious way to do it.<br />
If the implementation is hard to explain, it’s a bad idea.<br />
If the implementation is easy to explain, it may be a good idea.<br />
Namespaces are one honking great idea—let’s do more of those!</p>
<h2 id="examples">Examples</h2>
<p>Some examples of what is possible to define using schema-manager</p>
<pre><code># Separete types using namespaces
namespace com.accenture.common

    #####
    # define simple type aliases
    #####
    type id long &quot;long integer representing a unique id&quot;

    type code string(12):
        &quot;short strig, usually a mnemonic, used as alternate key or primary
        key when referencial static data&quot;

    type Name string(255) &quot;Standard Name&quot;

    type Version string(255) &quot;version of the aggregate&quot;

    type Username string(255) &quot;default username string&quot;

    type Description string(4000) &quot;Description&quot;

    #####
    # Define long documentation, in an arbitrary lenght
    #####
    type Money decimal(19,4):
        &quot;&quot;&quot;Decimal type, with precision of 19 and 4 decimal to represent monetary
        values
        It is known that 15 digits + 4 decimal digits are a good practice to represent storage.
        Some important articles:
        (four decimal places when using decimal to represent money)[https://stackoverflow.com/questions/34143961/why-are-four-decimal-places-suggested-when-using-decimal-to-represent-money]&quot;&quot;&quot;


namespace com.accenture.imat:
    &quot;&quot;&quot;The imat namespace&quot;&quot;&quot;

    # make the com.accenture.common types accessible without full qualified name
    from com.accenture.common import Name, Username,
            id, Money

    # abstract records are ment to be used by other records and cannot be used
    # to create physical schemas
    abstract record AuditField:

        created_date Date &quot;date of the record creation&quot;
        created_by Username &quot;username that created the record&quot;
        last_updated_date Date &quot;date that the record were last updated&quot;
        # Username type bein accessed using full qualified name
        last_updated_by com.accenture.common.Username:
            &quot;&quot;&quot;username who uptaded the record the last&quot;&quot;&quot;


    record KeyValue:
        &quot;&quot;&quot;key/value attribute to be used as a name/value set of values by
        other records.&quot;&quot;&quot;

        key Name
        value String(4000)


    record NameSpace:
        &quot;&quot;&quot;namespace to focus the domains into specific areas (namespaces)&quot;&quot;&quot;

        *code Code
        name Name
        description Description


    record BoundedContext:
        *code Code
        name Name &quot;BC Name&quot;
        description Description &quot;BC Description&quot;
        attributeMap *AttributeMap null &quot;BoundedContext attributeMap&quot;
        # will include the AuditField attributes at this location, 
        # keeping the order of the attributes in the record definition
        # (some schemas, like databases and ProtoBuf requires the correct order)
        !include AuditField     &quot;Expand the record in-line&quot;


    enum SchemaType:
        &quot;&quot;&quot;the types of schemas - flat, nestable or relational&quot;&quot;&quot;

        &quot;FLAT&quot;
        &quot;NESTABLE&quot;
        &quot;CUSTOM&quot;


    record DataTypes
        &quot;&quot;&quot;The data types used by the models&quot;&quot;&quot;

        *code Code
        description Description
        ### complex types can be defined in a nested way
        type enum :

            &quot;INTEGER&quot;
            &quot;FLOAT&quot;
            &quot;DECIMAL&quot;
            &quot;STRING&quot;
            &quot;DATE&quot;
            &quot;DATETIME&quot;


    record SchemaType:
        &quot;&quot;&quot;the data types associated with different technologies&quot;&quot;&quot;

        *code Code
        name Name
        type SchemaType
        dataTypes *DataType
        !include AuditField


    record Attribute:
        &quot;&quot;&quot;Attribute of an entity&quot;&quot;&quot;
        name Name
        description Description null
        attributeMap *AttributeMap null
        dataType !DataType
        isNull bool
        isPK bool
        order int
        lenght int null
        precision int null
        scale int null
        defaultValue string(4000) null
        domain string(4000) null
        list_of_values_code !ListOfValues null


    enum EntityType:
        &quot;&quot;&quot;Following DDD, as Entity, Value Objecs and Aggregates.
        A custom type is also available for other types of entities&quot;&quot;&quot;

        &quot;VALUE_OBJECT&quot;
        &quot;ENTITY&quot;
        &quot;AGGREGATE&quot;
        &quot;AGGREGATE_ROOT&quot;
        &quot;CUSTOM&quot;


    record Entity:
        &quot;&quot;&quot;Entity being represented in the logical model&quot;&quot;&quot;

        *code Code
        name Name
        description Description null
        type EntityType
        attributeMap *AttributeMap null
        attributes *Attribute null

    record SchemaSource:
        &quot;&quot;&quot;Identify the source of the schema, as it comes from a pre-defined
        structure, lide a software package (SAP, SalesForce) or pre-existing
        legacy structures&quot;&quot;&quot;

        *name Name
        desciption Description
        connectionString string(4000)
        password string(255)

    record Schema:

        *name Name
        *version Version
        *boundedContext !BoundedContext null
        *namespace !Namespace null
        type !SchemaType
        attributeMap *AttributeMap
        schemaSource SchemaSource null
        entities *Entity null
        !include AuditField

</code></pre>
