//////////////////////////////
//
// Schema manager parser language
// still in alpha state
//
/////////////////////////////

///////////////////
//
// Rules
//
//////////////////

?start: module_def (_NEWLINE | stmt)*

precision_x: INT
precision_y: INT
bool_value: BOOL
string_value: INLINE_STRING
decimal_value: DECIMAL
symbol_value: NAME
int_value: INT
_value: string_value | bool_value | symbol_value | int_value | decimal_value 
min_value: _value
max_value: _value
default_value: _value
// no explanation why need to redefine dotted_name, but it was the only way to
// make it work
type_name: NAME | DOTTED_NAME
optional: "?"

data_type: simple_type_declaration
			| map_type_declaration
			| set_type_declaration
			| list_type_declaration

simple_type_declaration: type_name [optional] ["(" [precision_x ","] precision_y ")"] _type_properties
_type_properties: ("min=" min_value | "max=" max_value | "default=" default_value)*

map_type_declaration: "map" "(" simple_type_declaration "," simple_type_declaration ")"
set_type_declaration: "set" "(" simple_type_declaration ")"
list_type_declaration: "list" "(" simple_type_declaration ")"

?type_instance: multiplicity? reference_fk? data_type
				| union_type

union_type: "[" data_type ("," data_type)+ "]"

lower_bound: INT
upper_bound: INT
multiplicity: "*" ["(" lower_bound ["," upper_bound] ")"]

reference_fk: "!"

// documentatin string styles
multiline_doc:  MULTILINE_STRING _NEWLINE
inline_doc: INLINE_STRING

?element_doc:  ":" _NEWLINE _INDENT multiline_doc _DEDENT | inline_doc _NEWLINE

arguments: argument ("," argument)*
arg_name: NAME
arg_value: _value
argument: [arg_name "="] arg_value

////////////////////////////////////////////////////////////
// document string for the module
////////////////////////////////////////////////////////////
module_doc: multiline_doc

////////////////////////////////////////////////////////////
//import statements
////////////////////////////////////////////////////////////
import_stmt: (import_name | import_from) _NEWLINE
import_name: "import" dotted_as_names
// note below: the ("." | "...") is necessary because "..." is tokenized as ELLIPSIS
import_from: "from" (dots? dotted_name | dots) "import" ("*" | "(" import_as_names ")" | import_as_names)
!dots: "."+
import_as_name: NAME ["as" NAME]
dotted_as_name: dotted_name ["as" NAME]
import_as_names: import_as_name ("," import_as_name)* [","]
dotted_as_names: dotted_as_name ("," dotted_as_name)*
dotted_name: NAME ("." NAME)*

////////////////////////////////////////////////////////////
// define a type
////////////////////////////////////////////////////////////

user_type_def: "type" NAME (data_type | union_type) (element_doc | _NEWLINE)

////////////////////////////////////////////////////////////
// define enumerators
////////////////////////////////////////////////////////////
symbol:  (NAME | INT) inline_doc? _NEWLINE
symbols: symbol+ _DEDENT
enum_def: "enum" NAME ":" _NEWLINE _INDENT multiline_doc? symbols

////////////////////////////////////////////////////////////
// define records
////////////////////////////////////////////////////////////
record_def: "record" NAME [parent_records] ":" _record_body
parent_records: "(" parent_record ("," parent_record)* ")"
_record_body: _NEWLINE _INDENT [multiline_doc] attributes _DEDENT
attributes: (attribute | include_stmt | discriminator_attrib)+
attribute: primary_key? NAME attribute_type
include_stmt: "!include" dotted_name (element_doc | _NEWLINE)
discriminator_attrib: discriminator NAME (element_doc | _NEWLINE)
?attribute_type: type_instance (element_doc | _NEWLINE)
				| record_def
				| enum_def
?parent_record: dotted_name [discriminator_value]
record_name: NAME
discriminator_value: "(" INLINE_STRING ")"
primary_key: "*"
discriminator: "%"

////////////////////////////////////////////////////////////
// Constant definitions
////////////////////////////////////////////////////////////
constant_value: INLINE_STRING | MULTILINE_STRING | DECIMAL | INT | BOOL
constant_def: dotted_name "=" [_NEWLINE] constant_value

////////////////////////////////////////////////////////////
// decorators
////////////////////////////////////////////////////////////
decorator: "@"dotted_name [ "(" [arguments] ")" ] _NEWLINE
decorators: decorator+
decorated: decorators (record_def)


//TODO: garantee the order or things:
// module doc -> import statements than the rest
module_def: _NEWLINE* module_doc _NEWLINE* import_stmt* 

?stmt: ( enum_def 
		| user_type_def 
		| decorated
		| record_def
		| constant_def)

///////////////////
//
// Tokens
//
//////////////////


//
// Numbers
//

DIGIT: "0".."9"
INT: DIGIT+
DECIMAL: INT "." INT? | "." INT

BOOL.3: "True"i | "False"i

SIGNED_DECIMAL.2: ("+" | "-") DECIMAL
SIGNED_INT.1: ("+" | "-") INT

//
// Strings
//

INLINE_STRING : /[ubf]?r?("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
MULTILINE_STRING: /[ubf]?r?(""".*?(?<!\\)(\\\\)*?"""|'''.*?(?<!\\)(\\\\)*?''')/is

//MULTILINE_STRING: /"""([^"\\]*(\\.[^"\\]*)*)"""/
//INLINE_STRING: /"([^"\\]*(\\.[^"\\]*)*)"/

//
// Names (Variables)
//

LCASE_LETTER: "a".."z"
UCASE_LETTER: "A".."Z"

LETTER: UCASE_LETTER | LCASE_LETTER

NAME: ("_" | LETTER ) ("_" | LETTER | DIGIT)*
DOTTED_NAME: NAME ("." NAME)+

//
// Whitespace
//
_WS_INLINE: (" "|/\t/)+
COMMENT: /#[^\n]*/
_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%ignore /[\t \f]+/  // WS
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
%declare _INDENT _DEDENT

